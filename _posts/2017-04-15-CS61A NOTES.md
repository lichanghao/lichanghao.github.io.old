---
layout:            post
title:             "CS61A NOTES"
date:              2017-04-15 17:10:00 +0300
tags:              CS61A
category:          Features
catalog:    		  true
header-img: 		  "img/post-bg-e2e-ux.jpg"
header-mask:       0.3
author:            Changhao Li
---



# CS61A NOTES
* [Lecture 1](#1) 
* [Lecture 2](#2)
* [Lecture 3](#3)
* [Lecture 4](#4)

<h2 id="1">Leture 1</h2>

*The introduction to this course and other notions*

- **the ability to explain things** to other people is important and what you will learn from your university.  

- Build good habits now for success in the future. Do not copy but you can learn from other people.

- Type of expressions.

- An **expression** describes a computation and evaluates to a value.	
- **Operator**, **operand**.

- **Objects** and **methods**.

- Sets.

- How to make a list reversed: `w[::-1]`

## Reading

- When Python evaluates an expression, it computes the value of expression.

- Some guiding principles of debugging are:

	1. Test incrementally
	2. Isolate errors
	3. Check your assumptions
	4. Consult others

<h2 id="2">Lecture 2</h2>

*Some base features and concepts of Python*

- **Built-in functions**, **Modules**, Types of expressions

- **Assignment statements**, left to right

- All the name in Python is **Reference**. It is very importance to understand this property.

- **Function signature**, **function body**

- **Environment**, **frame**

- **None**: None represent nothing in Python, a function that does not explicitly return a value will return a None. 
Pure functions, Non-pure functions

## Reading

- Def statements and assignment **bind names to values**, and any existing binding previous are lost.

- Boxes(Environment): a sequence of frames. And the concept: **Global frame**

- A name evaluates to the value bound to that name in the earliest frame of the current environment in which that name is found. 

- A new local frame is introduced every time a function is called, even if the same function is called twice.

- Some shared coding conventions:

	1. Function names are lowercase, with words separated by underscores. Descriptive names are encouraged.
	
	2. Function names typically evoke operations applied to arguments by the interpreter (e.g., `print`, `add`, `square`) or the name of the quantity that results (e.g., max, abs, sum).
	
	3. Parameter names are lowercase, with words separated by underscores. Single-word names are preferred.
	
	4. Parameter names should evoke the role of the parameter in the function, not just the kind of argument that is allowed.
	
	5. Single letter parameter names are acceptable when their role is obvious, but avoid "l" (lowercase ell), "O" (capital oh), or "I" (capital i) to avoid confusion with numerals.
	Abstract and hide the details of a function: the domain, the range, the relationship between input and output, side effects.

- The qualities of a good function:

	1. Each function should have exactly one job. One should divide multi-jobs function into small functions. 
	
	2. Try to avoid copying and pasting a block of code, using functional abstraction.
	
	3. Functions should be defined generally.


- Use **docstring** and **notes** to make functions and codes more readable. 

- Use `help <function_name> `to check the docstring of a function.

- Python 没有赋值表达式。形如`x = 1`这样的语句不是一个表达式，也没有返回值。

- Python中的变量全部都是引用，变量不是一块内存，而是一块内存上的标签。
[详细解释](https://my.oschina.net/leejun2005/blog/145911)

<h2 id="3">Lecture 3</h2>

*Some basic concepts and features of Python*

- A interesting and important feature of Python: You can define **multiple function** return values, just as
	
	```python
	def devide_exact(n, d):
		return n // d, n % d
	```

- **Default value**: should be placed in the *end* of the parameters list.

- Statements, clauses, headers, suites: 

	```python
	def absolute_value(x)
		"""Return the absolute value of x."""
		if x < 0:				
			return -x
		elif x == 0:
			return 0
		else:
			return x
		"""1 statement, 3 clauses, 3 headers, 3 suites"""
	```

## Reading

- **Control Statements**: control the flow of a program's execution, they have no value. They determine what the intepreter should do next.

- **Simple statements and compound statements**: simple statements end without a colon. Just like

	```python
	return mul(x,x) # a simple statement
	
	def square(x):
		return mul(x,x) # a compound statement
	```

- **Indention**: use spaces instead of tabs to indent codes, because the lenth of tabs is different in different OS.

- **Local assignments**: binding names in local frame, not influencing the global frame.

- **Boolean contexts**: In Python, 0, "", `None`, and `false` are false values. All other numbers are true values. Every *built-in kind* of data in Python has both true and false values.

- **Boolean operators**: sometimes they are determined without evaluating all of its subexpressions, a feature called *short-circuiting*. 

- **Iteration**: press *crtl+c* to force Python to stop looping.

- **Testing**:

	Assertions.
	
	```python
	assert fib(8) == 13, 'The 8th Fibonacci number should be 13' # the string will be displayed if the expreession evaluates to a false value.
	```
	
	 Doctests.
	
	```python
	def sum_naturals(n):
	        """Return the sum of the first n natural numbers.
	
	        >>> sum_naturals(10)
	        55
	        >>> sum_naturals(100)
	        5050
	        """
	        total, k = 0, 1
	        while k <= n:
	            total, k = total + k, k + 1
	        return total
	```
	
	```python 
	>>> from doctest import testmod
	>>> testmod() # to verify the functions in the global frame
	TestResults(failed=0, attempted=2)
	```
	
	```python
	>>> from doctest import run_docstring_examples
	>>> run_docstring_examples(sum_naturals, globals(), True)
	Finding tests in NoName
	Trying:
	    sum_naturals(10)
	Expecting:
	    55
	ok
	Trying:
	    sum_naturals(100)
	Expecting:
	    5050
	ok
	```

- When writing Python in files, all doctests in a file can be run by starting Python with the doctest command line option:

	```python3 -m doctest <python_source_file>```

- The key to effective testing is to write and run tests immediately after implementing new functions.

<h2 id="4">Leture 4</h2>

*Abstraction and High-order Functions*

- The code of fibonacci sequence:

	```python
	def fib(n)
	'''compute the nth Fibonacci number, for n >= 1.'''
		pred, curr = 0, 1
		while n > 1:
			pred, curr = curr, pred + curr
			n = n - 1
		return curr
	```
	
- A guide to designing function

	1. Give each function exactly one job.

	2. Don't repeat yourself. Inplement a process just once, but execute it many times.

	3. Define functions generally.

- Generalize functions(use higher-order function)

	example 1:
	
	```python
	def area(r, area_constant):
		assert r > 0, 'r should be non-negative'
		return r * r * area_constant
		
	def circle_area(r):
		return area(r, 3.1415926)
	
	def square_area(r)
		return area(r, 1)
	```
	example 2:
	
	```python
	def summation(k, term):
		total, k = 0, 1
		while k <= n:
			total, k = total + term(k), k + 1
		return total
	
	def identity(k):
		return k
		
	def cube(k):
		return pow(k, 3)
	```
	
- Nested function definition and Function as value

	```python
	def make_adder(n):
		def adder(k):
			return k + n
		return adder
	
	>>> add_three = make_adder(3)
	>>> add_three(4)
	7
	```

## Reading

- A powerful programming language is the ability to build **abstractions** by assigning names to common patterns and then to work on them.

- Functions that manipulate functions are called **higher-order functions**.

- Functions as general methods

	Here is an example computing the golden ratio using abstraction.
	
	```python
	def improve(update, close, guess=1):
		while not close(guess):
			guess = update(guess)
		return guess
		
	def golden_update(guess):
		return 1 / (guess + 1)
		
	def square_close_to_successor(guess):
		return approx_eq(guess * guess, guess + 1)
	
	def approx_eq(x, y, tolerance=1e-15):
		return abs(x - y) < tolerance
	```
	
	Naming and functions allow us to abstract away complexity. **Understanding the procedure of interpreting programs and problems** allows us to validate and inspect the process.
	
- **Nested definitions**

	If all the functions are defined in the global frame, it will become cluttered with names of small functions. Defining nested functions helps to solve this problem.
	
	```python
	'''Defining nested functions'''
	def sqrt(a):
		def sqrt_update(x):
			return x + a/x
		def sqrt_close(x):
			return approx_eq(x*x, a)
		return improve(sqrt_update, sqrt_close)
	```

- **Lexical scope**: the inner functions have assess to the names in the environment where they are defined.

- Obviously, the names of a local function(*closures*) do not interfere with names external to the function in which it is defined.

- The environment of a local function is extended.
	
- Functions as returned values

	Locally defined functions maintain their parent environment when they are returned. Here is an example.
	
	```python
	'''in this example, h(x) maintain its previous parent environment when returned.'''
	def square(x):
		return x * x
		
	def successor(x):
		return x + 1
	
	def compose1(f, g):
		def h(x):
			return f(g(x))
		return h
		
	def f(x): # this f(x) will not be called by h(x)
		return -x
		
	square_successor = compose1(square, successor)
	result = square_successor(12)
	```
	
## Lab 2

*Basic details of Python*

- The **priority** of **bool operators** in Python is `or < and < not`. 

```python
'''Using parenthses can be helpful to understand how a program will behave.'''
>>> True and not False or not True and False
>>> (True and (not False)) or ((not True) and False) # have the same effect but more readability
```
- **Short-circult operators**

```python
>>> True or 1/0 # will not cause any error 
True
```

- Question: deviders

	```python
	from math import sqrt
	def factors(n):
	    """prints out all of the numbers that 	divide 'n' evenly.
	    """
	    k = n
	    sqrt_n = sqrt(n)
	    while(k >= sqrt_n):
	        if n % k == 0:
	            print(k)
	            print(n / k)
	        k = k - 1
	    return
	
	factors(200)
	```
	
- Question: Factorials

	```python
	def falling(n, k):
		"""Compute the falling factorial of n to depth k"""
		k = 1
		while k > 0:
			k = k * n, n = n - 1, k = k - 1
		return k
	```

## Reading: Newton Iteration And Currying

*Newton Iteration And Currying*

- Using higher-order functions to convert a function that takes multiple arguments into a single-argument function.

	```python
	def make_newton_update(f, df):
	    def newton_update(x):
	        return x - f(x)/df(x)
	    return newton_update
	
	def iter_process(close_enough, update, guess=1):
	    while not close_enough(guess):
	        guess = update(guess)
	    return guess
	
	def make_newton_close(f):
	    def newton_close(x):
	        return abs(f(x)) < 1e-12
	    return newton_close
	
	def f(x):
	    return x * x * x
	
	def df(x):
	    return 3 * x * x
	
	def newton_iter(f, df):
	    return iter_process(make_newton_close(f), make_newton_update(f, df))
	
	print(newton_iter(f, df))
	```
	
- **Currying**: Using higher-order function to create a chain of functions that each take a single argument.

	```python
	def curried_pow(x):
		def h(y):
			return pow(x,y)
		return h
	
	>>> curried_pow(2)(3)
	8
	```
	Currying transfer:
	
	```python
	def curry2(f):
		def g(x):
			def h(y):
				return f(x, y)
			return h
		return g
	```
	Reverse currying transfer:
	
	```python
	def uncurry2(g):
		def f(x, y):
			return g(x)(y)
		return f
	```

# Reading: Lambda, First-Class Functions, Function Decorators

*Lambda*

- Sometimes we do not need to give a new function a name. In Python, we can create function values without a name with **lambda expressions**.

	```python
	def compose1(f, g):
		return lambda x: f(g(x)) # lambda expression
	```
	
- Despite it is more direct to use lambda expressions, compound lambda expressions are notoriously illegible.

	```python
	compose1 = lambda f,g: lambda x: f(g(x)) # difficult to read and understand
	```
	
*First-class functions*

- Elements with the fewest restrictions are said to have **first-class status**.
	1. They may be bound to names.
	2. They may be passed as arguments to functions.
	3. They may be returned as the results of functions.
	4. They may be included in data stuctures.

*Function decorators*

- Python provides special syntax to apply higher-order functions as part of executing a ```def``` statement, called a **decorator**.

	```python
	def trace(f)
		def wrapped(x):
			print('-> ', f, '(', x, ')')
			return f(x)
		return wrapped
	```
	They could be used to tracing the position of a function, which is the most common usage.
	
## Project1: Hog

### introduction

In Hog, two players alternate turns trying to **reach 100 points first**. On each turn, the current player chooses some number of dice to roll, **up to 10**. That player's score for the turn is **the sum of the dice outcomes**, unless any of the dice comes up a 1, in which case the score for the turn is only 1 point (**the Pig out rule**).

To spice up the game, we will play with some special rules:

**Free bacon**. **A player who chooses to roll zero dice scores one more than the largest digit in the opponent's score**.

Examples: if Player 1 has 42 points, Player 0 gains 1 + max(4, 2) = 5 points by rolling zero dice. If Player 1 has 48 points, Player 0 gains 1 + max(4, 8) = 9 points.

**Hog wild**. If the sum of both players' total scores is a multiple of seven (e.g., 14, 21, 35), then the current player rolls four-sided dice instead of the usual six-sided dice.
**Hogtimus prime**. If at the end of a turn the sum of the scores of both players is a prime number, then the points earned during the current turn are also added to the score of the current leader at the end of the turn. If after adding the boost, the total score happens to be another prime number, **subsequent boosts are not applied**. In addition, if the two scores are equal, no boost is applied to either score.

Example 1 Player 0 has 5 points and Player 1 has 20; it is Player 0's turn. Player 0 scores 4 more points, bringing the total number of points to 29. The current leader is Player 1, who has more than Player 0's 9 points, so 4 points are added to Player 1's score. Player 0 now has 9 points, and Player 1 has 24.

Example 2: Player 0 has 34 points and Player 1 has 29; it is Player 1's turn. Player 1 scores 8 more points, bringing the total number of points to 71. The current leader is Player 1 with 37 points, so 8 more points are added to Player 1's score. Player 0 now has 34 points, and Player 1 has 45 points.