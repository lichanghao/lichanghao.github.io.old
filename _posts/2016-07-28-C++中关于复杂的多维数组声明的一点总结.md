---
layout:     post
title:      "C++中关于复杂的多维数组声明的一点总结"
subtitle:   ""
date:       2016-07-28 11:10:00 +0300
author:     "lichanghao"
header-img: "img/post-bg-2015.jpg"
header-mask: 0.3
catalog:    true
tags:
    - C++
 

---
最近在读c++ primer，多维数组的声明这里感觉有点绕，特意记个笔记
   
```c++
#include "stdafx.h"
#include <iostream>
using namespace std;
int _tmain(int argc, _TCHAR* argv[])
{
	char word1[][20] = {"word1","word2"};//一个“二维数组”，等价于一个指向【由20个char组成的数组】的指针，20必须填，前面的可以不填，由编译器补全
	char (*word2)[20] ;				   //一个指向【由20个char组成的数组】的指针，20必须填
	char *word3[20] = {"word1","word2"}; //一个由20个char型指针组成的数组，20不填也可以，不填的话由编译器补全
	char **word4 ;						//一个指向char*型指针的指针
	word2 = word1; 
	word4 = word3;
	cout << word1[1] << endl; //word1[1]为char*类型，准确的说是char [20]类型
	cout << word2[0] << endl; //word2[0]为char*类型，准确的说是char [20]类型
	cout << word3[1] << endl; //word3[1]为char*类型，char*指向数据的宽度由编译器自动补全，word3的容量为20
	cout << word4[1] << endl; //和上面一行原理完全相同
	cout << sizeof(word1[0]) << endl; //输出结果为20，证明了word1 为 char[20] 类型
	cout << sizeof(word3[0]) << endl; //输出结果为4，证明了word3是一个指针

	/*实际上，word1和word2完全等价，word3和word4完全等价
	  word[]在声明中，就等于(*word)。因为C++中数组的底层实现就是指针。
	  C++中没有真正的多维数组，多维数组实际上是“数组的数组”（C++ Primer 第五版的原话）
	  [const_expr]和*都是type的一部分，即使[]内不填东西，也要由编译器补全。用sizeof测试得出的结论是，测试[const_expr]类得出的字节长度，是（base type的长度）*（const_expr）。而*类的结果是4，也就是windows下指针的字节长度。
	  []操作符的优先级大于*，所以不难理解，为什么word1和word2完全等价，word3和word4完全等价
	*/

	system ("pause");
	return 0;
	/*还有一点需要注意的是，尽管数组在底层的实现方式就是指针，但是初始化一个数组的时候
	例如 char word1[][20] = {"word1","word2"}; 实际上开辟了一块新内存，因此我们可以对数组中的值进行修改。
	但是 char *word3[20] = {"word1","word2"}; 这样的声明，则是将指针指向了字符串常量，我们不能对指针所指的常量进行修改。*/
}

```
