---
layout:            post
title:             "Python中的变量与赋值"
date:              2017-05-01 13:50:00 +0300
tags:              Python
category:          Features
catalog:    		  true
header-img: 		  "img/post-bg-e2e-ux.jpg"
header-mask:       0.3
author:            Changhao Li
---

# Python中的变量与赋值

## 变量即引用

在Python中，**所有的变量都是引用**。这就意味着，当你写下```a = b```这样的语句时，```a```变量和```b```变量实际上指向了内存中的同一块空间。

```python
>>> a = 4
>>> b = a
>>> print(id(a),id(b))
4297537888 4297537888
```
在C++中，如果a不是一个引用的话，```a = b```将会在内存中开辟一块新空间，将b的值赋给a。同时，C++中是严格区分函数参数传值与传地址的，而在Python中，所有的函数参数都是引用，也就是传地址。如果不加区分不同语言中的赋值语句的含义，很容易引入bug。

函数传参数为不可变类型时，修改参数并不会影响外部变量的值，和传值的效果是一样的。而传参数为可变类型时，内部的修改会影响外部的值。


## 可变对象与不可变对象

**Python规定数值、元组、字符串等为不可变对象，列表、字典为可变对象**。可变对象与不可变对象的区别在于，**内存单元的值是否可以被改变**。对指向不可变对象的变量进行操作时，该变量要重新指向其他内存，因为不可变对象的内存单元不可改变。相反，对指向可变对象的操作是直接在原来的内存上执行的。

我的理解：可变对象类似于指针（引用），不可变对象类似于值。

```python
>>> b = 5
>>> print(id(a),id(b)) #改变b的值以后，b变量指向的内存地址改变
4297537888 4297537904
```

```python
>>> c = ['hello']
>>> d = c
>>> print(id(c),id(d))
4383488264 4383488264
>>> d[0] = 'world'
>>> print(id(c),id(d)) #d列表中的元素变化，但d变量与c变量仍然指向同一块内存。
4383488264 4383488264
>>> print(c, d) #改变d以后，c也一起改变，因为c和d指向同一块内存。
['world'] ['world']
```
## ==操作符和is操作符

```==```操作符将两个变量所指的对象进行比较，如果值相等则返回True，否则返回False。

```python
>>> a == b
False
>>> c == d
True
```

```is```操作符直接将两个变量所指对象的内存地址进行比较，如果两个变量指的是同一个对象，则返回True，否则返回False。

```python
>>> a is b
False
>>> c is d
True
```

## 深拷贝与浅拷贝

当一个复杂对象中包含有指针或者引用时，拷贝这个动作就有两种含义。

- 浅拷贝：只单纯拷贝该对象中所有信息，也就是逐字拷贝。
- 深拷贝：如果对象中包含指针或者引用，不去拷贝指针的值，而是去拷贝指针所指的内存的值。

可以看出，如果复杂对象中包含指针或者引用，浅拷贝会直接将指针/引用**原封不动**拷贝下来，得到的复制对象是不完全的，所以这种方式被称为浅拷贝。而深拷贝将对象包含的所有信息都复制下来，并且复制对象和原对象在内存上是**完全独立**的。我们往往需要的是深拷贝，浅拷贝经常会成为程序中bug的诱因。

在Python中，```copy```模块的```copy()```函数可以复制对象，但它的方式是浅拷贝。示例如下：

```python
>>> from copy import copy
	 e = ['hello', ['world']]
	 f = copy.copy(e) #浅拷贝
	 f[0] = 'Hello'
	 print(e, f)
	 f[1][0] = 'hello'
	 print(e, f)

['hello', ['world']] ['Hello', ['world']]
['hello', ['hello']] ['Hello', ['hello']]
```
e和f明明是指向两个不同的对象，但改变```f[1][0]```后，e也受到了影响。这就是因为```copy()```函数使用的方式是浅拷贝。我们可以将列表理解为一个指针，f只是e的一个逐字拷贝版本，因此```f[1]```与```e[1]```指向的是同一个列表对象，它们共享一块内存。

在```copy```模块中还有一个```deepcopy()```函数，从名字就可以看出它是一个深拷贝函数。如果将上面示例的```f = copy.copy(e)```改为```f = copy.deepcopy(e)```，不难推断出新的输出结果为:

```python
['hello', ['world']] ['Hello', ['world']]
['hello', ['world']] ['Hello', ['hello']]
```
## Python中的垃圾回收机制